#include <iostream>
#include <string>

using namespace std;

// 클래스의 선언
// class라는 예약어와 함께
// 대문자로 시작하는 내용으로 클래스 이름 설정
class Student {
    // 멤버 변수(데이터)는 private: 코드 블록에 정리
private: // 외부에서 직접 접근하는 것을 막는다. -> 무결성
    string name;
    int age;
public: // 외부에서 사용할 수 있는 것을 정의하는 공간
    void setName(string n) { name = n; }
    string getName() {
        // this 포인터 예약어 
        // 현재 클래스를 객체화한 인스턴스(객체)를 가리키는
        // 일종의 대명사 역할을 하며, 객체의 주소값이 담겨있다.
        return this->name;
    };
    void setAge(int a) { age = a; }
    int getAge() { return this->age; }

    // 생성자(constructor)
    // 클래스를 기반으로 객체를 초기화할 때,
    // 멤버 변수의 초기값을 설정하고 그외 여러가지 기본 설정을 하여
    // 객체가 온전한 상태로 초기화될 수 있도록 설정하는
    // 특수한 메서드다.
    // - 클래스와 동일한 이름으로 작성한다.
    // - 반환타입을 작성하지 않는다.
    // - return으로 값을 반환하지 않는다.
    //      - return으로 생성자를 바로 종료하고자 한다면
    //          return;으로 종료한다.
    
    // 기본 생성자
    // 매개변수 없이 초기화
    Student() {
        // 전달받은 정보가 없으므로, 기본값으로 설정하는 부분
        name = "noName";
        age = 0;
    }

    // 기본 생성자 외 다른 생성자를 만들 수 있다.
    // 하지만 생성자는 클래스 이름과 동일해야 하는데
    // 기본적으로 함수는 같은 이름으로 정의할 수 없다.
    // 그런데 매개변수의 개수, 종류, 순서가 다르면
    // 서로 다른 메서드로 인식하는 것을
    // 오버로딩(overloading)이라고 부르며
    // 이를 통해 같은 이름으로 여러 개의 메서드를 정의할 수 있다.
    // 생성자2
    Student(string n, int a) {
        // 전달받은 값으로 초기값 설정
        name = n;
        age = a;
    }
    
    // 생성자2와 동일한 구성으로 매개변수를 받고 있지만
    // 그 순서가 다르기 때문에 다른 메서드로 인식한다.
    // 중요한 점은, 시그니처에서 고려하는 것은
    // 매개변수의 타입만 고려하고 변수명은 고려하지 않는다는 점이다.
    Student(int a, string n) {
        name = n;
        age = a;
    }

    // 위의 생성자와 시그니처가 같지만 매개변수명은 다르다.
    // 하지만 시그니처를 고려할 때 변수명은 취급하지 않으므로
    // 같은 메서드를 두 번 정의한 셈이 된다.
    //Student(int age2, string name2) {
        //name = name2;
        //age = age2;
    //}

    // 복사 생성자: 다른 객체를 복사하여 초기화할 때 사용
    Student(const Student& other) {
        name = other.name;
        age = other.age;
    }

    // 소멸자
    // 객체가 소멸될 때 필요한 정리 작업을 수행한다.
    ~Student() {
        // 동적 할당된 메모리 해제 등의 정리 작업
    }

};


int main()
{
    // 클래스
    // 구조체에서 발전된 개념으로, 데이터(변수)뿐만 아니라
    // 함수(메서드)까지 포함된 형태의 자료구조를 의미한다.
    // 변수로의 직접적인 접근을 방지하고 메서드를 통해서만
    // 값을 사용, 변경하도록 제어하는 시스템이 갖추어져 있다.
    // 이를 접근 제어 지시자를 이용해서 접근을 제어하며
    // 그 종류는 아래와 같다.
    // 1. public
    // 클래스 외의 공간에서 클래스를 호출하여 사용할 때,
    // 제한없이 접근할 수 있음을 나타내는 접근 제어 지시자

    // 2. private
    // 해당 클래스 안에서만 접근이 가능함을 나타내는
    // 접근 제어 지시자이다.
    // 외부에서 해당 데이터 혹은 메서드에 접근하려고 할 때
    // 보이지 않도록 설정한다.(가시성)

    // 3. protected
    // 상속과 관련된 접근 제어 지시자



    // 클래스의 객체화와 그 사용
    // 클래스를 객체화(인스턴스)하려면
    // 클래스 타입으로 변수를 선언하듯이 하면 된다.
    Student hong; // 기본생성자 호출
    Student kim("김유신", 31); // 사용자 정의 생성자 호출

    // 각 객체의 정보 출력
    // 값에 접근할 때에는 getter와 setter로만 접근해야 한다.
    cout << "이름: " << kim.getName() << endl;
    cout << "나이: " << kim.getAge() << endl;







}
