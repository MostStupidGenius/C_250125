#include <iostream>
#include <string>

using namespace std;

int main()
{
    // 람다식 : 익명함수
    // 이름이 없는 상태로 만드는 함수로,
    // 간단한 내용의 함수를 작성해야 할 때, 임시적으로 생성하는
    // 함수를 가리킨다.
    // [캡처절](매개변수들) -> 리턴타입 {로직작성}
    // return타입의 경우, 매개변수와 캡처 절로 전달받은 값을 사용하기 때문에
    // 추론이 가능하다. 추론이 가능한 경우에는 return타입을 적는
    // -> returntype 부분을 생략이 가능하다.
    auto add = [](int a, int b) /*-> int*/ {return a + b; };
    int result = add(1, 5);
    cout << result << endl;

    // 람다식은 선언과 동시에 그 사용이 가능하다.
    // 람다식의 선언문 뒤에 소괄호()와 함께 정의했던 매개변수에 맞는
    // 인자, 인수를 전달하면 즉시 사용된다.
    cout << [result](int a, int b) { return a * b * result ; }(3, 33) << endl;

    // 캡처 절
    // 람다식의 앞쪽에 대괄호[]안에 작성하는 절로,
    // 일반적으로는 비워두며, 현재 코드 위치(외부)의 변수나 참조 변수를
    // 함수 내부에서 사용하고자 하는 경우에 작성한다.
    // 
    // =
    // 모든 외부 변수에 그대로 접근 가능

    // &
    // 모든 외부 변수를 참조로 접근 가능

    // 특정변수명
    // 특정 변수명을 캡처절 안에 작성하는 경우,
    // 함수 내부에서 해당 변수에 접근이 가능하다.
    
    // &특정변수명
    // 특정 변수를 참조로 접근 가능
    
    // 반점,
    // 위의 조건들을 여러 개 쓰고 싶을 때 사용하는 나열 기호

    // 반점을 사용하는 경우
    // 먼저 작성된 것을 기본값으로 하되 이후에 나오는 조건을
    // 더 높은 우선순위로 적용한다.

    // 예시
    // [=, &result]
    // 외부 변수를 모두 그대로 접근하되(값 캡쳐)
    // result 변수에 대해서만 참조로 접근을 하겠다.

    // =========================
    // auto와 결합한 람다식
    // 매개 변수의 타입을 auto로 지정하면, 입력되는 값의 타입을
    // 자동으로 설정하기 때문에
    // 특정 타입이 아니라 모든 타입에 대응하는
    // 제네릭 함수를 작성할 수 있게 된다.
    auto add2 = [](auto x, auto y) {return x + y; };

    // 다양한 타입에 사용 가능
    int sum1 = add2(3, 7);
    double sum2 = add2(12.7, 9.2);
    auto sum3 = add2(13.9, 3);

    cout << "sum1: " << sum1 << endl;
    cout << "sum2: " << sum2 << endl;
    cout << "sum3: " << sum3 << endl;

    // mutable
    // 외부에서 캡처한 변수, 참조 등의 값을 기본적으로 변경이 불가능하다.
    // 이러한 변경을 가능케 해주는 예약어가 mutable 예약어이다.
    int counter(0);
    // mutable을 사용하면 외부에서 전달받은 변수를 변경할 수 있다.
    auto increment = [counter]() mutable {return ++counter; };

    // mutable이 없다면 오류가 발생한다.
    //auto increment = [counter]() {return ++counter; };
}
