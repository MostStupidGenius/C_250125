#include <iostream>
#include <string>

using namespace std;
// 스마트 포인터
// 일반적인 포인터는 직접 메모리 해제를 해야 하는데,
// 수동 메모리 관리는 이중 해제 등 여러 문제가 발생하기 때문에
// 이를 자동으로 관리해주는 포인터 개념을 만들었다.
// 스마트 포인터를 사용하기 위해서는
#include <memory>
// 위 인클루드 문을 사용해야 한다.

// 스마트 포인터의 종류
// - unique_ptr
// 독점적 소유권을 가진 포인터로, 그 값을 복사하는 것이 아니라
// 단일 객체나 리소스에 대한 배타적인 소유권을 보장하는 포인터다.
// 특징: 복사 불가능, 이동만 가능(move()), 소유권 독점

int main()
{
    // unique_ptr
    // 소유권 독점 포인터
    
    // 10이라는 값을 새로운 메모리 주소에 할당하고
    // 이 주소를 유니크 포인터로 관리하겠다
    unique_ptr<int> ptrInt(new int(10));

    // 기존 raw pointer처럼 포인터 접근 연산자로 값에 접근할 수 있다.
    cout << *ptrInt << endl;

    // 다른 변수를 만들어서 그 주소값을 복사하여 전달하려고 해도
    // 내부적으로 copy 함수를 없앴기 때문에 복사를 할 수가 없다.
    // 유니크 포인터를 해당 메모리 주소에 대한 소유권을 온전히 보장한다.
    //unique_ptr<int> ptrInt2 = ptrInt;

    // 이러한 유니크 포인터의 독점적인 소유권은 복사는 불가능하고
    // 오직 소유권 이전만 가능하다.
    // move()

    // 소유권 이전
    auto ptr2 = move(ptrInt);
    
    // 소유권을 ptr2 변수에 전달했기 때문에
    // 독점적 소유권은 ptr2에서 보유하게 되었으며,
    // 기존 ptrInt는 해당 메모리 주소에 접근할 권한을 잃었다.
    //cout << *ptrInt << endl; // 컴파일 오류 발생
    cout << *ptr2 << endl;

    // 공유 소유권 포인터
    // shared_ptr
    // 참조 카운티 방식의 공유 소유권 스마트 포인터로,
    // 여러 포인터가 동일한 메모리 주소를 안전하게 공유하고
    // 접근할 수 있도록 하는 역할을 한다.
    // -> 열쇠 관리자: 주소값의 복사를 관리하는 관리자를 두는 것과 같다.
    shared_ptr<int> sharedInt(new int(20));
    shared_ptr<int> sharedInt2 = sharedInt;

    // 기존의 raw 포인터를 무분별하게 주소값을 복사하여 전달할 수 있었다.
    // 공유 소유권 포인터를 이용하면 얼마나 많은 포인터가 생성되었는지 확인할 수 있다.
    // .user_count()를 사용하면 현재 공유되고 있는 포인터의 개수를 반환한다.
    cout << sharedInt.use_count() << endl; // 2
    
    // 해당 포인터의 주소를 더 이상 참조하지 않는다.
    // ->reset()
    sharedInt2.reset();

    // 다시 참조하고 있는 포인터의 개수를 출력해보면
    cout << sharedInt.use_count() << endl; // 1

    // 현재 포인터가 공유 소유권 포인터들 중 유일한지 여부를 반환하는 함수
    // .unique()
    cout << sharedInt.unique() << endl; // true이므로 1 출력

    // 공유 포인터의 문제점은 순환 참조가 발생할 수 있다는 점이다.

    // 이러한 공유 포인터의 순환 참조 문제를 해결하기 위해 나온 포인터
    // 보조 스마트 포인터 weak_ptr
    // 객체의 수명 주기에 영향을 주지 않고 참조를 관리한다.
    // 공유 포인터의 공유 받더라도 참조 카운트를 증가시키지 않는다.
    // 복잡한 객체 관계에서 발생할 수 있는 메모리 누수를 예방할 수 있다.
    // 객체의 존재 여부 확인이 가능하다 -> 안전한 객체 접근 보장
    shared_ptr<int> shared(new int(30));// 공유 포인터 생성
    
    // 보조 포인터 생성
    // 공유 포인터의 참조 카운트를 증가시키지 않고 참조를 받아올 수 있으며,
    // 객체의 생명 주기에 영향을 주지 않고 접근할 수 있다.
    weak_ptr<int> weakInt = shared;
    
    cout << "참조 횟수: " << shared.use_count() << endl;

    // 공유 포인터에서 주소값을 메모리 해제
    //shared.reset();

    // 관리하는 주소값이 메모리에서 해제되었는지 확인
    // .expired();
    // 메모리 상에서 해당 주소값에 더 이상 접근할 수 없으면
    // true 1을 반환.
    // 아직 메모리 주소를 참조 하는 포인터가 존재하면
    // false 0을 반환
    cout << "메모리해제 여부: " << weakInt.expired() << endl;

    // shared_ptr 객체를 생성하여 반환
    // lock()
    shared = weakInt.lock();
    
    cout << *shared << endl;

    // 보조 포인터의 사용법
    // 기존의 unique 포인터나 공유 포인터를 전달받아서
    // 다른 포인터가 모두 메모리 주소값을 참조하지 않는지 여부를 확인 후
    // 가장 마지막에 참조를 해제하여 안전하게 메모리를 해제하는,
    // 메모리 해제 마지막 문단속을 하는 역할을 한다고 표현할 수 있다.
}
